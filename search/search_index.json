{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u0158e\u0161en\u00ed \u00faloh line\u00e1rn\u00edho programov\u00e1n\u00ed pomoc\u00ed knihovny PuLP","text":"<p>Vypracoval: Petr Kotlan</p> <p>Materi\u00e1l vznikl v r\u00e1mci bakal\u00e1\u0159sk\u00e9 pr\u00e1ce Optimalizace investi\u010dn\u00edch prost\u0159edk\u016f z hlediska v\u00fdnosu fotovoltaick\u00fdch elektr\u00e1ren.</p> <p>Tento tutori\u00e1l se zam\u011b\u0159uje na pr\u00e1ci s knihovnou PuLP, kter\u00e1 umo\u017e\u0148uje \u0159e\u0161it \u00falohy line\u00e1rn\u00edho programov\u00e1n\u00ed. Samotn\u00fd materi\u00e1l se problematikou line\u00e1rn\u00edho programov\u00e1n\u00ed nazab\u00fdv\u00e1, pouze implementac9 a \u0159e\u0161en\u00edm \u00faloh. P\u0159edpokl\u00e1d\u00e1 se z\u00e1kladn\u00ed znalost jazyka Python.</p> <p>Z\u00e1rov\u011b\u0148 se p\u0159edpokl\u00e1d\u00e1, \u017ee \u010dten\u00e1\u0159 um\u00ed pracovat s knihovnou <code>matplotlib</code>, kter\u00e1 je vyu\u017eita pro vizualizaci v\u00fdsledk\u016f.   </p>"},{"location":"#zaklady-pouziti-pulp","title":"Z\u00e1klady pou\u017eit\u00ed PuLP","text":"<p>V t\u00e9to \u010d\u00e1sti si uk\u00e1\u017eeme z\u00e1kladn\u00ed pou\u017eit\u00ed knihovny PuLP na jednoduch\u00e9m p\u0159\u00edkladu. Jak pracovat s jednotliv\u00fdmi t\u0159\u00eddami, jak vytvo\u0159it \u00falohu line\u00e1rn\u00edho programov\u00e1n\u00ed a jak ji vy\u0159e\u0161it.</p>"},{"location":"#instalace-a-import","title":"Instalace a import","text":"<p>Pro za\u010d\u00e1tek je nutn\u00e9 nainstalovat knihovnu PuLP pomoc\u00ed n\u011bkter\u00e9ho bal\u00ed\u010dkovac\u00edho syst\u00e9mu pro Python. N\u00e1sleduj\u00edc\u00ed p\u0159\u00edklady ukazuj\u00ed instalaci pomoc\u00ed bal\u00ed\u010dkovac\u00edch syst\u00e9m\u016f Pip, Conda a Poetry.</p> PipCondaPoetry <pre><code>pip install pulp\n</code></pre> <pre><code>conda install pulp\n</code></pre> <pre><code>poetry add pulp\n</code></pre> <p>N\u00e1sledn\u011b je nutn\u00e9 knihovnu PuLP a dal\u0161\u00ed pot\u0159ebn\u00e9 knihovny importovat.</p> <pre><code>from pulp import *\nimport matplotlib.pyplot as plt # (1)!\n</code></pre> <ol> <li>Knihovna pro vizualizaci v\u00fdsledk\u016f</li> </ol>"},{"location":"#vytvoreni-ulohy-linearniho-programovani","title":"Vytvo\u0159en\u00ed \u00falohy line\u00e1rn\u00edho programov\u00e1n\u00ed","text":"<p>Model \u00falohy line\u00e1rn\u00edho programov\u00e1n\u00ed se skl\u00e1d\u00e1 z n\u011bkolika \u010d\u00e1st\u00ed.</p> <ul> <li>LpProblem - Definice \u00falohy</li> <li>LpVariable - Definice prom\u011bnn\u00fdch</li> <li>LpAffineExpression - Line\u00e1rn\u00ed kombinace prom\u011bnn\u00fdch</li> <li>LpConstraint - Definice omezen\u00ed</li> </ul> <p>Pro n\u00e1zornost si v\u0161e vyzkou\u0161\u00edme na n\u00e1sleduj\u00edc\u00edm p\u0159\u00edkladu.</p> \\[ \\begin{align*} \\max \\quad &amp; 600x_1 + 400x_2 \\\\ \\text{za podm\u00ednek} \\quad &amp; x_1 + 0.25x_2 \\leq 45 \\\\ &amp; 2x_1 + 0.25x_2 \\leq 45 \\\\ &amp; 4x_1 + 2x_2 \\leq 100 \\\\ &amp; 3x_1 + x_2 \\leq 300 \\\\ &amp; x_1 + 4x_2 \\leq 50 \\\\ &amp; x_1, x_2 \\geq 0 \\end{align*} \\] <p>Pro motivaci si p\u0159edstavme, \u017ee se jedn\u00e1 o podnik vyr\u00e1b\u011bj\u00edc\u00ed dva druhy v\u00fdrobk\u016f. V\u00fdrobek 1 m\u00e1 zisk 600 K\u010d a v\u00fdrobek 2 m\u00e1 zisk 400 K\u010d. D\u00e1le m\u00e1me n\u011bkolik omezen\u00ed, nap\u0159\u00edklad omezen\u00ed v\u00fdrobn\u00edch kapacit, kter\u00e9 jsou vyj\u00e1d\u0159eny v jednotk\u00e1ch v\u00fdrobk\u016f. C\u00edlem je maximalizovat zisk.</p>"},{"location":"#lpproblem","title":"LpProblem","text":"<p>Z\u00e1kladem cel\u00e9ho probl\u00e9mu je instance t\u0159\u00eddy <code>LpProblem</code>, kter\u00e1 reprezentuje celou \u00falohu. Do t\u00e9to instance se n\u00e1sledn\u011b p\u0159id\u00e1vaj\u00ed prom\u011bnn\u00e9, omezen\u00ed a c\u00edlov\u00e1 funkce. Samotn\u00e1 t\u0159\u00edda <code>LpProblem</code> m\u00e1 dva nastaviteln\u00e9 parametry.</p> <ul> <li><code>name</code> - N\u00e1zev \u00falohy</li> <li><code>sense</code> - Typ optimalizace</li> </ul> <p>Parametr <code>name</code> nen\u00ed nijak d\u016fle\u017eit\u00fd pro samotnou optimalizaci. M\u00e1 sv\u00e9 vyu\u017eit\u00ed p\u0159i ukl\u00e1d\u00e1n\u00ed probl\u00e9mu do souboru, kter\u00e9 si uk\u00e1\u017eeme pozd\u011bji.</p> <p>Parametr <code>sense</code> ur\u010duje o jak\u00fd typ optimalitace se jedn\u00e1. Typ tohoto parametru je <code>int</code>, ale p\u0159i \u0159e\u0161en\u00ed model vr\u00e1t\u00ed chybovou hl\u00e1\u0161ku, pokud <code>sense</code> nen\u00ed <code>1</code> nebo <code>-1</code>. PuLP m\u00e1 pro tento parametr p\u0159ipraven\u00e9 dv\u011b konstanty <code>LpMinimize</code> a <code>LpMaximize</code>, kter\u00e9 reprezentuj\u00ed minimalizaci a maximalizaci. Defaultn\u00ed hodnota je <code>LpMinimize</code>.</p> Vytvo\u0159en\u00ed instance t\u0159\u00eddy LpProblem<pre><code>prob = LpProblem(\"Max_v\u00fdroby\", LpMaximize) # (1)!\n</code></pre> <ol> <li>V\u00fdtah z dokumentace. Odkaz na dokumentaci <pre><code>class LpProblem(\n    name: str = \"NoName\",\n    sense: int = const.LpMinimize\n    )\n</code></pre> <pre><code>Creates an LP Problem\n\nThis function creates a new LP Problem with the specified associated parameters\n\n:param name: name of the problem used in the output .lp file\n:param sense: of the LP problem objective. Either ~pulp.const.LpMinimize (default) or ~pulp.const.LpMaximize.\n:return: An LP Problem\n</code></pre></li> </ol> <p>Inicializovali jsme maximaliza\u010dn\u00ed probl\u00e9m s n\u00e1zvem <code>Max_v\u00fdroby</code>. T\u0159\u00edd\u00e1 <code>LpProblem</code> m\u00e1 n\u011bkolik d\u016fle\u017eit\u00fdch atribut\u016f a metod.</p> <p>Mezi d\u016fle\u017eit\u00e9 atributy pat\u0159\u00ed:</p> <ul> <li><code>objective</code> - C\u00edlov\u00e1 funkce probl\u00e9mu</li> <li><code>constraints</code> - Se\u0159azen\u00fd slovn\u00edk omezen\u00ed</li> <li><code>status</code> - Stav \u0159e\u0161en\u00ed probl\u00e9mu</li> </ul> <p>D\u016fle\u017eit\u00e9 metody:</p> <ul> <li><code>solve()</code> - Vy\u0159e\u0161\u00ed dan\u00fd probl\u00e9m</li> <li><code>variables()</code> - Vr\u00e1t\u00ed seznam prom\u011bnn\u00fdch</li> <li><code>toDict()</code> nebo <code>to_dict()</code> - Vr\u00e1t\u00ed slovn\u00edk s v\u00fdsledky</li> </ul> <p>Co vrac\u00ed jednotliv\u00e9 metody a atributy si zat\u00edm neuk\u00e1\u017eeme, proto\u017ee jsme zat\u00edm probl\u00e9mu nep\u0159i\u0159adili \u017e\u00e1dn\u00e9 prom\u011bnn\u00e9, omezen\u00ed ani c\u00edlovou funkci. Vr\u00e1t\u00edm se k nim pozd\u011bji.</p>"},{"location":"#lpvariable","title":"LpVariable","text":"<pre><code>x1 = LpVariable(\"x1\", lowBound=0) # (1)!\nx2 = LpVariable(\"x2\", lowBound=0)\n...\n</code></pre> <ol> <li>V\u00fdtah z dokumentace. Odkaz na dokumentaci <pre><code>class LpVariable(\n    name: str,\n    lowBound: Any | None = None,\n    upBound: Any | None = None,\n    cat: str = const.LpContinuous,\n    e: Any | None = None\n)\n</code></pre> <pre><code>This class models an LP Variable with the specified associated parameters\n\n:param name: The name of the variable used in the output .lp file\n:param lowBound: The lower bound on this variable's range.\n    Default is negative infinity\n:param upBound: The upper bound on this variable's range.\n    Default is positive infinity\n:param cat: The category this variable is in, Integer, Binary or\n    Continuous(default)\n:param e: Used for column based modelling: relates to the variable's\n    existence in the objective function and constraints\n</code></pre></li> </ol>"},{"location":"#lpaffineexpression","title":"LpAffineExpression","text":"<pre><code>f = LpAffineExpression([(x1, 2), (x2, 3)]) # (1)!\n</code></pre> <ol> <li>V\u00fdtah z dokumentace. Odkaz na dokumentaci <pre><code>class LpAffineExpression(\n    e: Any | None = None,\n    constant: int = 0,\n    name: Any | None = None\n)\n</code></pre> <pre><code>A linear combination of LpVariables&lt;LpVariable&gt;. Can be initialised with the following:\n\n#. e = None: an empty Expression\n#. e = dict: gives an expression with the values being the coefficients of the keys (order of terms is undetermined)\n#. e = list or generator of 2-tuples: equivalent to dict.items()\n#. e = LpElement: an expression of length 1 with the coefficient 1\n#. e = other: the constant is initialised as e\n\nExamples:\n\n&gt;&gt;&gt; f=LpAffineExpression(LpElement('x'))\n&gt;&gt;&gt; f\n1*x + 0\n&gt;&gt;&gt; x_name = ['x_0', 'x_1', 'x_2']\n&gt;&gt;&gt; x = [LpVariable(x_name[i], lowBound = 0, upBound = 10) for i in range(3) ]\n&gt;&gt;&gt; c = LpAffineExpression([ (x[0],1), (x[1],-3), (x[2],4)])\n&gt;&gt;&gt; c\n1*x_0 + -3*x_1 + 4*x_2 + 0\n</code></pre></li> </ol>"},{"location":"#lpconstraint","title":"LpConstraint","text":"<pre><code>c1 = LpConstraint(x1 + x2, sense=LE, rhs=4) # (1)!\nc2 = LpConstraint(x1 - x2, sense=GE, rhs=1)\n...\n</code></pre> <ol> <li>V\u00fdtah z dokumentace. Odkaz na dokumentaci <pre><code>class LpConstraint(\n    e: Any | None = None,\n    sense: int = const.LpConstraintEQ,\n    name: Any | None = None,\n    rhs: Any | None = None\n)\n</code></pre> <pre><code>:param e: an instance of LpAffineExpression\n:param sense: one of ~pulp.const.LpConstraintEQ, ~pulp.const.LpConstraintGE, ~pulp.const.LpConstraintLE (0, 1, -1 respectively)\n:param name: identifying string\n:param rhs: numerical value of constraint target\n</code></pre></li> </ol>"},{"location":"#reseni-ulohy","title":"\u0158e\u0161en\u00ed \u00falohy","text":"<pre><code>status = prob.solve()\nprint(LpStatus[status])\nprint(f\"x1 = {value(x1)}, x2 = {value(x2)}\")\nprint(f\"Optimalizovan\u00e1 hodnota: {value(prob.objective)}\")\n</code></pre> Output<pre><code>Optimal\nx1 = 0.0, x2 = 0.0\nOptimalizovan\u00e1 hodnota: 0.0\n</code></pre>"},{"location":"#priklady","title":"P\u0159\u00edklady","text":""}]}